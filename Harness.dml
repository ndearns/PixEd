object Harness
{
    attr        img             : Image;
    attr        tex             : Texture;
    attr        mpos            : Vector2;
    attr        mdown           : Boolean;
    attr        sdown           : Boolean;
    attr        bcolor          : Color;
    attr        t_res           : Coord;  "number of tile pixels in Tile side"
    attr        p_span          : Coord;  "number of screen pixels in Pixel or ColorWell"
    attr        x_tile          : Coord;
    attr        y_tile          : Coord;
    attr        x_palette       : Coord;
    attr        y_palette       : Coord;
    attr        x_save          : Coord;
    attr        y_save          : Coord;
    attr        x_add_tile      : Coord;
    attr        y_add_tile      : Coord;
    attr        x_del_tile      : Coord;
    attr        y_del_tile      : Coord;
    attr        x_next_tile     : Coord;
    attr        y_next_tile     : Coord;
    attr        x_prev_tile     : Coord;
    attr        y_prev_tile     : Coord;


    relation    ui              : Harness -> Raylib;
    relation    graphic         : Harness -> Graphic;
    relation    uses_tile       : Harness -> Tile;
    relation    uses_pixel      : Harness -> Pixel;
    relation    palette         : Harness -> Palette;
    relation    uses_color_well : Harness -> ColorWell;

    proc        main() : ExitCode 
                {
                    let the_harness : Harness = new Harness;
                    let the_ui      : Raylib  = new Raylib;
                    let the_graphic : Graphic = new Graphic;
                    let the_palette : Palette = new Palette;

                    call the_harness.set_t_res( 24 );
                    call the_harness.set_p_span( 32 );
                    call the_harness.set_x_tile( 3 * the_harness.p_span() );
                    call the_harness.set_y_tile( 3 * the_harness.p_span() );
                    call the_harness.set_x_palette( 
                                     the_harness.x_tile() +
                                     the_harness.p_span() +
                                    (the_harness.t_res() * the_harness.p_span()) );
                    call the_harness.set_y_palette( 3 * the_harness.p_span() );
                    call the_harness.ui_link( the_ui );
                    call the_harness.graphic_link( the_graphic );
                    call the_graphic.initialise( the_harness.t_res(), the_harness.p_span() );
                    call the_harness.palette_link( the_palette );
                    call the_palette.initialise();

                        call PixelGraphics::swa.println('PixelGraphics running...');

                    call the_harness.start();

                    call the_harness.ui_unlink();

                    return ExitCode::Ok;
                };

    proc        start()
                {
                    call self.ui().init_window( (3 * p_span()) + (t_res() * p_span()) + (7*p_span()),
                                                (3 * p_span()) + (t_res() * p_span()) + (3*p_span()),
                                                'PixelGraphics dev harness' );

                    call self.ui().set_target_fps( 60 );

                          "window initialised; can now load textures"

                    call self.set_img( ui().load_image( 'dev_image.png' ) );
                    call self.set_tex( ui().load_texture( 'BlueTile.png' ) );

                            "loop infinitely, until window closed"

                    foreach i : FrameCount
                        | 0 <= i and !ui().window_should_close()
                            =>
                                call self.do_frame( i );

                    call self.ui().close_window();
                };

    proc        do_frame( frame_number : FrameCount ) 
                {
                                    "deal with timers"

                                   "get mouse inputs"

                    call set_mdown( false );
                    if ui().mouse_button_is_down( 0 )
                        => call set_mdown( true );

                    call self.set_mpos( ui().get_mouse_position() );

                                    "get key inputs"

                    call self.set_sdown( ui().is_key_down( KEY_LEFT_SHIFT ) );

                                    "call game logic"

                    let tile_hit : Boolean = mdown_on_tile_grid();
                    if mdown() and tile_hit and !sdown() => paint_pixel_under_mouse();
                    if mdown() and tile_hit and  sdown() => erase_pixel_under_mouse();

                    let palette_hit : Boolean = mdown_on_palette_grid();
                    if mdown() and palette_hit => select_color_well_under_mouse();

                    call EventQueue::defaultEQ().service_queue();

                                        "render"

                    call ui().begin_drawing();

                        call ui().clear_background( WHITE );
                        call ui().draw_texture( tex(), 300, 300, WHITE);
                        call self.draw_graphic();
                        call self.draw_palette();
                        call self.draw_prev_button();
                        call self.draw_next_button();
                        call self.draw_add_button();
                        call self.draw_del_button();
                        call self.draw_save_button();
                        call self.draw_load_button();
                        call self.draw_time();

                    call ui().end_drawing();
                };

    proc        select_color_well_under_mouse()
                {
                    let  x : Coord = 0;
                    let  y : Coord = 0;
                    set  x = ((((Coord)self.mpos()..x) - self.x_palette()) / self.p_span());
                    set  y = ((((Coord)self.mpos()..y) - self.y_palette()) / self.p_span());
                    call self.set_bcolor( self.palette().color_wells()[y*3 + x].color() );
                };

    proc        mdown_on_palette_grid() : Boolean
                {
                    let result : Boolean = false;
                    let dx : Coord = 0;
                    set dx = self.x_palette() + (self.p_span() * 3);
                    let dy : Coord = 0;
                    set dy = self.y_palette() + 
                            (self.p_span() * (Coord)(self.palette().color_wells()..size()) / 3);

                    if self.x_palette() < mpos()..x and mpos()..x < dx and
                       self.y_palette() < mpos()..y and mpos()..y < dy
                       =>
                          set result = true;
                    return result;
                };

    proc        mdown_on_tile_grid() : Boolean
                {
                    let result : Boolean = false;
                    let tile_span  : Coord = (Coord)self.t_res();
                    let pixel_span : Coord = (Coord)self.p_span();
                    let x : Coord = (Coord)self.x_tile();
                    let y : Coord = (Coord)self.y_tile();
                    let dx : Coord = (Coord)0;
                    let dy : Coord = (Coord)0;
                    set dx = x + (tile_span * pixel_span);
                    set dy = y + (tile_span * pixel_span);

                    if x < mpos()..x and mpos()..x < dx and
                       y < mpos()..y and mpos()..y < dy
                       =>
                          set result = true;
                    return result;
                };

    proc        paint_pixel_under_mouse()
                {
                    let pixel_span : Coord = self.graphic().grid_span();
                    let  x : Coord = 0;
                    let  y : Coord = 0;
                    set  x = ((((Coord)self.mpos()..x) - self.x_tile()) / pixel_span);
                    set  y = ((((Coord)self.mpos()..y) - self.y_tile()) / pixel_span);
                    foreach pix : self.graphic().tiles()[0].pixels()
                        | pix.x() = x and pix.y() = y
                        => call pix.set_color( self.bcolor() );
                };

    proc        erase_pixel_under_mouse()
                {
                    let pixel_span : Coord = self.graphic().grid_span();
                    let  x : Coord = 0;
                    let  y : Coord = 0;
                    set  x = ((((Coord)self.mpos()..x) - self.x_tile()) / pixel_span);
                    set  y = ((((Coord)self.mpos()..y) - self.y_tile()) / pixel_span);
                    foreach pix : self.graphic().tiles()[0].pixels()
                        | pix.x() = x and pix.y() = y
                        => call pix.set_color( self.graphic().background_color() );
                };

    proc        draw_next_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (2*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (3*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( '>>', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_prev_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (1*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (3*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( '<<', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_add_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (1*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (2*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( '+', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_del_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (2*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (2*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( '-', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_save_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (1*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (1*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( 'S', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_load_button()
                {
                    let x : Coord = 0;
                    set x = (3*p_span()) + (t_res()*p_span()) + (2*p_span());
                    let y : Coord = 0;
                    set y = (3*p_span()) + (t_res()*p_span()) - (1*p_span());
                    call ui().draw_rectangle_lines( x, y, p_span(), p_span(), DARKGRAY );
                    call ui().draw_text( 'L', x+p_span()/5, y+2, p_span(), DARKGRAY );
                };

    proc        draw_palette()
                {
                    foreach n : Coord | 0 <= n and n < self.palette().color_wells()..size()
                        => call self.draw_color_well( n );
                    call ui().draw_rectangle_lines(
                            self.x_palette(), self.y_palette(),
                            3 * self.p_span(), (self.palette().color_wells()..size() / 3) * self.p_span(),
                            DARKGRAY
                    );
                };

    proc        draw_color_well( n : Coord )
                {
                    let x_well : Coord = 0;
                    let y_well : Coord = 0;

                    set x_well = self.x_palette() + (self.p_span() * (n%3));
                    set y_well = self.y_palette() + ((n/3) * self.p_span());
                    call ui().draw_rectangle( x_well, y_well, self.p_span(), self.p_span(),
                                              self.palette().color_wells()[n].color());
                };

    proc        draw_graphic()
                {
                    foreach tile : self.graphic().tiles()
                        => call self.draw_tile( tile );
                    call self.draw_graphic_grid();
                };

    proc        draw_tile( tile : Tile )
                {
                    foreach p : tile.pixels()
                        => call self.draw_pixel( p );
                };

    proc        draw_pixel( p : Pixel )
                {
                    let x : Coord = 0;
                    set x = self.x_tile() + (self.p_span() * p.x());
                    let y : Coord = 0;
                    set y = self.y_tile() + (self.p_span() * p.y());
                    call ui().draw_rectangle( x, y, self.p_span(), self.p_span(), p.color());
                };

    proc        draw_graphic_grid()
                {
                    foreach n : Coord | 0 <= n and n < (self.t_res()*self.t_res())
                        => call self.draw_grid_cell( n );
                };

    proc        draw_grid_cell( n : Coord )
                {
                    let x : Coord = 0;
                    set x = self.x_tile() + (self.p_span() * (n%self.t_res()));
                    let y : Coord = 0;
                    set y = self.y_tile() + (self.p_span() * (n/self.t_res()));
                    call ui().draw_rectangle_lines( x, y, self.p_span(), self.p_span(), LIGHTGRAY);
                };

    proc        draw_mouse_coords() {
                    call ui().draw_text( mpos()..x, 20, 50, self.p_span(), BLACK );
                    call ui().draw_text( mpos()..y, 20, 80, self.p_span(), BLACK );
                };

    proc        draw_time()
                {
                    let  screen_width : Coord = ui().get_screen_width();
                    call ui().draw_text( ui().time_HHMMSS(), (screen_width/2) - 80, 20, self.p_span(), PINK );
                };
};
