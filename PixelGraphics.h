
#pragma once
/*--------------------------------------------------------------------------------

	PixelGraphics.h 

	

	Generated by dml from PixelGraphics.dml

--------------------------------------------------------------------------------*/

#include <cstdint>
#include <set>
#include <vector>
#include <functional>
#include <string>
#include <iostream>
#include <chrono>
#include <thread>
#include "EventQueue.h"

#include "PixelGraphicsProvided.h"

namespace PixelGraphics {

[[maybe_unused]] static bool TRACE=false;  // Turn event logging on/off; outputs to std::clog

class SWA {
    bool m_quit_servicing_queue  = false;
    int  m_sleep_milliseconds = 0;
public:

	void print(std::string text) {
		std::cout << text;
	}
	void println(std::string text) {
		std::cout << text << std::endl;
	}
    void run() {
        do {
            EventQueue::defaultEQ()->service_queue();
            if (m_sleep_milliseconds > 0) {
                sleep();
            }
        } while( !m_quit_servicing_queue );        
    }
    void quit() {
        m_quit_servicing_queue = true;
    }
    void set_sleep_milliseconds( int milliseconds ) {
        // set non-zero value to force thread to yield ot toher tasks
        m_sleep_milliseconds = milliseconds;
    }
    void sleep() {
        using namespace std::chrono_literals;
        using ms = std::chrono::duration<int, std::milli>;
        
        std::this_thread::sleep_for( ms(m_sleep_milliseconds) );
    }
};

static SWA* swa = new SWA;

// Object types
class Harness;
class Raylib;
class Graphic;
class Tile;
class Pixel;
class Palette;
class ColorWell;


// Built-in types
// 
	using State = void;

	template<typename A>
	using Set = std::set<A>;

	template<typename A>
	using Vector = std::vector<A>;

	using Boolean = bool;

	struct Timer {
		uint16_t m_interval{0};
		std::function<void()> e_callback{nullptr};
		Timer() {};
		Timer(uint16_t tick, std::function<void()> callback)
			: m_interval{ tick }, e_callback{ callback } {};
		void cancel(){ delete this; };
	};

// User defined types

	using ImageRef = void *;
	using FrameCount = size_t;
	using Coord = uint16_t;
	using Size = uint16_t;
	using Label = std::string;


// User enum types

	enum ExitCode {
		Ok,
		Error,
	};


};
